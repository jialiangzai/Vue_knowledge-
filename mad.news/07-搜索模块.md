# 搜索模块

### 01-搜索中心-基础布局

> 使用vant的搜索组件

步骤：

1. 了解搜索组件van-search用法
2. 绑定搜索关键词数据和事件
3. 使用模版和样式切换联想搜索和搜索历史效果

搜索框：

`views/search/index.vue`

- keyWord 搜索关键字
- onSearch 搜索函数（虚拟键盘 enter 触发）

```html
<van-search v-model.trim="keyWord" placeholder="请输入搜索关键词" shape="round" @search="onSearch"/>
```

* 搜索展示模版

1. 根据输入关键词=》联想补全搜索关键词：

```html
<van-cell-group class="suggest-box">
  <!-- span高亮联想关键词 -->
  <van-cell icon="search"><p><span>j</span>ava</p></van-cell>
</van-cell-group>
```

```less
.suggest-box{
  /deep/ .van-cell{
    padding: 10px 20px;
    color: #999;
    p{
      span{
        color: red;
      }
    }
  }
}
```

2. 搜索后的关键词历史记录：

```html
<div class="history-box">
  <div class="head">
    <span>历史记录</span>
    <van-icon name="delete"></van-icon>
  </div>
  <van-cell-group>
    <van-cell>
      <a class="word_btn">电脑</a>
      <van-icon class="close_btn" slot="right-icon" name="cross"/>
    </van-cell>
  </van-cell-group>
</div>
```

```less
.history-box {
  padding: 0 20px;
  .head{
    line-height: 36px;
    color: #999;
    text-align: left;
    .van-icon{
      font-size: 16px;
      float: right;
      margin-top: 10px;;
    }
  }
  .van-cell{
    padding: 10px 0;
  }
  .word_btn{
    color:#3296fa;
  }
  .close_btn{
    margin-top:5px;
    color: #999;
  }
}
```

* 历史记录与联想搜索切换

```diff
+		<van-cell-group class="suggest-box" v-if="keyWord">
      <van-cell icon="search"><span>j</span>ava</van-cell>
    </van-cell-group>
+    <div class="history-box" v-else>
      <div class="head">
        <span>历史记录</span>
        <van-icon name="delete"></van-icon>
      </div>
      <van-cell-group>
        <van-cell>
          <a class="word_btn">电脑</a>
          <van-icon class="close_btn" slot="right-icon" name="cross"/>
        </van-cell>
      </van-cell-group>
    </div>
```

### 02-搜索中心-历史记录

> 处理搜索历史，存储到本地和跳转结果页

1. 声明假数据和渲染：

- 约定key

```js
// 约定本地存储的key     TT_SEARCH_HISTORY
// 约定本地存储的value   ["电脑","手机","123"]
const TT_SEARCH_HISTORY = 'TT_SEARCH_HISTORY'
```

- 初始化历史记录数据

```js
historyList: JSON.parse(window.localStorage.getItem(TT_SEARCH_HISTORY)) || []
```

- 有历史记录数据才显示历史记录

```html
<div class="history-box" v-else-if="historyList.length">
```

- 渲染

```html
<van-cell v-for="key in historyList" :key="key">
 <a @click="toSearch(key)" class="word_btn">{{key}}</a>
 <van-icon @click="delHistory(key)" class="close_btn" slot="right-icon" name="cross"/>
</van-cell>
```

2. 操作历史数据：

- 删除

```js
delHistory (key) {
  const index = this.historyList.findIndex(item => item === key)
  this.historyList.splice(index, 1)
  // 同步本地数据
  window.localStorage.setItem(TT_SEARCH_HISTORY, JSON.stringify(this.historyList))
}
```

- 根据历史去搜索结果页面=>可以和搜索输入框共用一个函数

```js
onSearch (key) {
  this.$router.push({ path: '/search/result', query: { q: key } })
}
```

- 清空搜索历史数据

```html
<van-icon name="delete" @click="clearHistory()"></van-icon>
```

```js
clearHistory () {
  this.historyList = []
  window.localStorage.setItem(TT_SEARCH_HISTORY, null)
}
```

3. 进行搜索：用户输入关键词后，回车确认进入搜索页

```js
    onSearch (key) {
      // @search 触发条件：PC端按下回车键触发，手机上按下虚拟键盘（输入法）中的enter键|搜索键
      if (!key) return false
      // 存储搜索历史 (key不能存重复的)  集合
      const keySet = new Set(this.historyList)
      keySet.add(key)
      this.historyList = Array.from(keySet) // 或者 [...keySet]
      //  更新本地缓存：存储在本地  需要的是数组格式
      window.localStorage.setItem(KEY, JSON.stringify(this.historyList))
      // 跳转搜索结果
      this.$router.push({ path: '/search/result', query: { q: key } })
    },
```



### 03-搜索中心-联想搜索(预习)

> 搜索确认前，调用API展示联想词（自动补全）

1. API封装

- 封装API   `src/api/article.js`=》获取联想建议（自动补全）

```js
/**
 * 联想自动补全
 * @param {*} q 搜索词
 */
export function suggest (q) {
  return request.get('suggestion', {
    params: {
      q
    }
  })
}
```

2. 设置数据，监听搜索关键词变化，调用接口获取联想词并渲染

- 监听 关键字 改变，进行联想补全。

```js
watch: {
  keyWord () {
    // 清除定时器异步任务
    this.timer && clearTimeout(this.timer)
    // 函数防抖：当用户停止输入后600ms后处理联想词；
    // 如果600ms内再次输入内容，会清除上一次的任务，重新计时
    // 缓存定时器=>this.timer
    this.timer = setTimeout(async () => {
      if (!this.keyWord) {
        // 为空 =>删除联想词结果
        this.suggestList = []
        return
      }
      const { status, data } = await suggest(this.keyWord)
      if (status === 200) {
        // 处理数据模版=》html字符串
        this.suggestList = data.options.map((item) => item.toLowerCase().replace(this.keyWord, `<span>${this.keyWord}</span>`))
       // console.log(this.suggestList)
      }
    }, 600)
  }
}
```

说明：注意处理**当前输入关键词高亮显示**=》需要格式化返回的数据为html字符串形式

- 渲染

```diff
<!-- 联想搜索 -->关于key重复建议加index，因为联想不做复杂操作
<van-cell-group class="suggest-box" v-if="keyWord">
+  <van-cell icon="search" :key="sug" v-for="sug in suggestList">
+    <p v-html="sug" @click="onSearch(sug.replace(`<span>${keyWord}</span>`,keyWord))">
-      <!-- <span>j</span>ava -->
    </p>
  </van-cell>
</van-cell-group>
```

扩展阅读：

> 函数防抖和节流

- 函数防抖：指定延迟时间内，再次执行，**清除上一次执行**，重新执行延时。=》实现=〉setTimeout
  - lodash提供 `debounce`   https://www.lodashjs.com/docs/latest#_debouncefunc-wait0-options
- 函数节流：指定延迟时间内，只执行一次任务。=>实现=》计算时间戳（保证指定延迟时间内会执行一次）
  * 首次正常执行；
  * 在延迟时间内，再次执行，**必须等当前时间和上次执行时间之差大于指定延迟时间**，才能执行。

> 使用第三方库实现

lodash提供 `throttle`  https://www.lodashjs.com/docs/latest#_throttlefunc-wait0-options

- [lodash安全漏洞](https://www.infoq.cn/article/k7C-ZvXKOHh284ToEy9K)   如果只是个别功能，建议自己实现。



### 04-搜索结果-基础布局

> 使用模版布局结果列表

依赖数据：

```js
  data () {
    return {
      list: [],
      loading: false,
      finished: false
    }
  },
  methods: {
    onLoad () {
      // 异步更新数据
      // setTimeout 仅做示例，真实场景中一般为 ajax 请求
      setTimeout(() => {
        for (let i = 0; i < 10; i++) {
          this.list.push(this.list.length + 1)
        }

        // 加载状态结束
        this.loading = false

        // 数据全部加载完成
        if (this.list.length >= 40) {
          this.finished = true
        }
      }, 1000)
    }
  }
```

```html
  <div class="container">
    <!-- 导航固定定位 fixed -->
    <van-nav-bar
      fixed
      title="搜索结果"
      left-arrow
      @click-left="$router.back()"
    />
    <!-- 文章列表 -->
    <van-list
      v-model="loading"
      :finished="finished"
      @load="onLoad"
      finished-text="没有更多了"
    >
      <van-cell v-for="item in list" :key="item">
        <div class="article_item">
          <h3 class="van-ellipsis">
            PullRefresh下拉刷新PullRefresh下拉刷新下拉刷新下拉刷新
          </h3>
          <div class="img_box">
            <van-image
              class="w100"
              fit="cover"
              src="https://img.yzcdn.cn/vant/cat.jpeg"
            />
            <!-- <van-image
              class="w33"
              fit="cover"
              src="https://img.yzcdn.cn/vant/cat.jpeg"
            /> -->
          </div>
          <div class="info_box">
            <span>你像一阵风</span>
            <span>8评论</span>
            <span>10分钟前</span>
          </div>
        </div>
      </van-cell>
    </van-list>
  </div>
```

```less
.container {
  padding-top: 46px;
  height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
}
.article_item {
  h3 {
    font-weight: normal;
    line-height: 2;
  }
  .img_box {
    display: flex;
    justify-content: space-between;
    .w33 {
      width: 33%;
      height: 90px;
    }
    .w100 {
      height: 180px;
      width: 100%;
    }
  }
  .info_box {
    color: #999;
    line-height: 2;
    position: relative;
    span {
      padding-right: 10px;
    }
  }
}
```

### 05-搜索结果-上拉加载（作业）

> 根据关键词调用接口获取文章列表数据渲染，实现上拉加载更多（分页）

1. 封装后台API获取搜索文章列表数据并渲染

- 封装API `src/api/article.js`=>获取搜索结果

```js
/**
 * 搜索文章
 * @param {*} page 页码
 * @param {*} per_page 每页条数
 * @param {*} q 搜索关键字
 */
// eslint-disable-next-line camelcase
export function searchArticles ({ page = 1, per_page = 20, q }) {
  return request.get('search', {
    params: {
      page,
      per_page,
      q
    }
  })
}
```

- 申明数据

```js
  data () {
    return {
      loading: false,
      finished: false,
      // 文章列表
      articles: []
    }
  },
  created () {
    // 初始化默认=》查询条件数据
    this.query = {
      page: 1,
      q: this.$route.query.keyWord
    }
  },
```

- 获取数据

```js
  methods: {
    async onLoad () {
      //  加载数据
      const { status, data } = await searchArticles(this.query)
      if (status === 200) {
        this.articles.push(...data.results)
        // 加载完成，关闭加载效果
        this.loading = false
        // 判断数据是否全部加载完
        if (data.total_count === this.articles.length) {
          this.finished = true
        } else {
          // 页码加一
          this.query.page++
        }
      }
    }
  }
```

- 渲染组件

```html
    <!-- 文章列表 -->
    <van-list @load="onLoad" v-model="loading" :finished="finished" finished-text="没有更多了">
      <van-cell-group>
        <van-cell :to="'/article/'+item.art_id.toString()" v-for="item in articles" :key="item.art_id.toString()">
          <div class="article_item">
            <h3 class="van-ellipsis">{{item.title}}</h3>
            <div class="img_box" v-if="item.cover.type===3">
              <van-image class="w33" fit="cover" :src="item.cover.images[0]" />
              <van-image class="w33" fit="cover" :src="item.cover.images[1]" />
              <van-image class="w33" fit="cover" :src="item.cover.images[2]" />
            </div>
            <div class="img_box" v-if="item.cover.type===1">
              <van-image class="w100" fit="cover" :src="item.cover.images[0]" />
            </div>
            <div class="info_box">
              <span>{{item.aut_name}}</span>
              <span>{{item.comm_count}}评论</span>
              <span>{{item.pubdate|relTime}}</span>
            </div>
          </div>
        </van-cell>
      </van-cell-group>
    </van-list>
```

2. 修改文章详情路由，添加文章详情跳转

- 修改路由规则，文章详情路由改成动态路由规则。

`src/router/routes.js`

```diff
-   { path: '/article', name: 'article', component: Article, meta: { keepalive: true } }
+  { path: '/article/:id', name: 'article', component: Article, meta: { keepalive: true } }
```

- 修改主页的文章列表，添加详情跳转 

`src/views/home/articleList.vue`

```diff
<van-cell
+ :to="`/article/${item.art_id.toString()}`"
v-for="item in list"
:key="item.art_id.toString()"
>
 // 点击更多操作=》阻止事件冒泡
 <span
 v-if="$store.state.user"
+ @click.stop="openMore(item.art_id.toString())"
 class="close"
 >
```

注意：点击更多操作=》打开详情页问题

`Do not use built-in or reserved HTML elements as component id: article`

说明：组件name（ID）不能和原生html标签名重复

### 第五天重点总结





***  扩展

object.creat创建纯对象用于继承创建对象，将被继承对象的prototype赋给此对象，并且调用被继承对象的方法来为其初始化。（因此new obj()不仅能继承prototype，也能继承构造函数内属性）危险

Object.create的实现核心代码:

```js
Object.create =  function (o) {
    var F = function () {};
    F.prototype = o;
    return new F();
};
new obj()的核心实现代码:

var o1 = new Object();
o1.[[Prototype]] = Base.prototype;
Base.call(o1);
```

可见: 创建函数，将传递的对象赋给函数的prototype，再返回函数实例。
