# 文章详情

### 01-文章详情-基础布局

> 使用模版布局文章详情静态内容

- 内容基础布局	

`src/views/article/index.vue`

```html
  <div class='container'>
    <van-nav-bar fixed title="文章详情" left-arrow @click-left="$router.back()" />
    <div class="detail">
      <h3 class="title">文章的标题</h3>
      <div class="author">
        <van-image round width="1rem" height="1rem" fit="fill" src="https://img.yzcdn.cn/vant/cat.jpeg" />
        <div class="text">
          <p class="name">一阵清风</p>
          <p class="time">两周内</p>
        </div>
        <van-button round size="small" type="info">+ 关注</van-button>
      </div>
      <div class="content">
        <p>文章的内容</p>
      </div>
      <div class="zan">
        <van-button round size="small" class="active" plain icon="like-o">点赞</van-button>
        &nbsp;&nbsp;&nbsp;&nbsp;
        <van-button round size="small" plain icon="delete">不喜欢</van-button>
      </div>
    </div>
  </div>
```

```less
.container {
  height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
}
.detail {
  padding: 46px 10px 44px;
  height: 1000%;
  .title {
    font-size: 18px;
    line-height: 2;
  }
  .zan{
    text-align: center;
    padding: 10px 0;
    .active{
      border-color:red;
      color: red;
    }
  }
  .author {
    padding: 10px 0;
    display: flex;
    .text {
      flex: 1;
      padding-left: 10px;
      line-height: 1.5;
      text-align: left;
      .name {
        font-size: 14px;
        margin: 0;
      }
      .time {
        margin: 0;
        font-size: 12px;
        color: #999;
      }
    }
  }
  // 内容中包含：img 特别宽  code pre 不能换行
  .content {
    padding: 20px 0;
    overflow: hidden;
    white-space: pre-wrap;
    word-break: break-all;
    /deep/ img{
      max-width:100%;
      background: #f9f9f9;
    }
    /deep/ code{
      white-space: pre-wrap;
    }
    /deep/ pre{
      white-space: pre-wrap;
    }
  }
}
```

### 02-文章详情-内容渲染和阅读记忆

> 获取文章详情并渲染，记录上次文章浏览的位置（阅读记忆）

1. 封装获取文章详情的接口=》获取新闻文章详情

`api/article.js`

```js
/**
 * 获取文章详情
 * @param {*} id 根据文章ID获取文章详情
 */
export function getDetailById (id) {
  return request.get(`articles/${id}`)
}
```

2. 文章详情页首次加载后会缓存，在activated钩子中，根据文章ID判断是否需要重新加载数据

> 什么时候来获取文章详情？ 激活组件获取文章详情。

说明：当前访问的文章ID和上一次访问的文章ID不一致时，就是不同的文章。

* 如果访问A文章，离开组件到列表，然后访问B文章，**重新获取文章数据**。
* 如果访问A文章，离开组件到列表，**再次访问A文章**，不用再次获取数据，**滚动到阅读的位置**。

```js
import { getDetailById } from '@/api/article'
export default {
  name: 'article-detail',
  data () {
    return {
      // 文章详情
      detail: {
      },
      // 上次看过文章的阅读位置
      scrollTop: 0
    }
  },
  activated () {
    // 当前文章ID：this.$route.params.id  (类型：字符串)
    // 之前文章ID：this.detail.art_id.toString()  (art_id 有值)
    if (this.detail.art_id?.toString() !== this.$route.params.id) {
      // 重置阅读位置
      this.scrollTop = 0
      // 获取详情
      this.getDetail()
    } else {
      // 滚到到上次阅读位置
      this.$refs.container.scrollTop = this.scrollTop
    }
  },
  methods: {
    // 获取文章详情
    async getDetail () {
      const { status, data } = await getDetailById(this.$route.params.id)
      if (status === 200) {
        this.detail = data
      }
    },
    // 记录阅读位置
    remember (e) {
      // console.log(e.target.scrollTop)
      this.scrollTop = e.target.scrollTop
    }
  }
}
```

```html
<div class='container' @scroll="remember($event)" ref="container">
    <van-nav-bar fixed title="文章详情" left-arrow @click-left="$router.back()" />
    <div class="detail" v-if="article">
      <h3 class="title">{{article.title}}</h3>
      <div class="author">
        <van-image round width="1rem" height="1rem" fit="fill" :src="article.aut_photo" />
        <div class="text">
          <p class="name">{{article.aut_name}}</p>
          <p class="time">{{article.pubdate|relTime}}</p>
        </div>
        <van-button round size="small" type="info">
           {{article.is_followed?'已关注':'+ 关注'}}
        </van-button>
      </div>
      <div class="content" v-html="article.content"></div>
      <div class="zan">
        <van-button round size="small" :class="{active:article.attitude===1}" plain icon="like-o">点赞</van-button>
        &nbsp;&nbsp;&nbsp;&nbsp;
        <van-button round size="small" :class="{active:article.attitude===0}" plain icon="delete">不喜欢</van-button>
      </div>
    </div>
</div>
```



### 03-文章详情-关注与取消关注

> 封装用户关注API，处理关注操作

1. 封装API `src/api/user.js`=>

```js
/**
 * 关注用户
 * @param {*} target 用户ID
 */
export function follow (target) {
  return request.post('user/followings', { target })
}

/**
 * 取关用户
 * @param {*} target 用户ID
 */
export function unFollow (target) {
  return request.delete(`user/followings/${target}`)
}
```

2. 关注按钮绑定事件，处理关注功能=》**取反**

```html
<van-button @click="toggleFllow" round size="small" type="info">
  {{article.is_followed?'已关注':'+ 关注'}}
</van-button>
```

```js
import { follow, unFollow } from '@/api/user'
    
// 添加/取消关注
async toggleFllow () {
  try {
    if (this.detail.is_followed) {
      // 取关
      await unFollow(this.detail.aut_id)
      this.$toast.success('取关成功！')
      this.detail.is_followed = false
    } else {
      // 关注
      await follow(this.detail.aut_id)
      this.$toast.success('关注成功！')
      this.detail.is_followed = true
    }
  } catch (error) {
    this.$toast.fail(error.message)
  }
}
```



### 04-文章详情-点赞与不喜欢

> 实现对文章的点赞和不喜欢功能

* 封装API `src/api/article.js`

```js
/**
 * 对文章不喜欢
 * @param {*} target 文章ID
 */
export function disLike (target) {
  return request.post('article/dislikes', {
    target
  })
}

/**
 * 取消对文章不喜欢
 * @param {*} target 文章ID
 */
export function unDisLike (target) {
  return request.delete(`article/dislikes/${target}`)
}

/**
 * 对文章点赞
 * @param {*} target 文章ID
 */
export function like (target) {
  return request.post('article/likings', {
    target
  })
}

/**
 * 取消对文章点赞
 * @param {*} target 文章ID
 */
export function unLike (target) {
  return request.delete(`article/likings/${target}`)
}
```

* 绑定事件

```html
      <div class="zan">
        <van-button @click="toggleLike(1)" round size="small" :class="{active:article.attitude===1}" plain icon="like-o">点赞</van-button>&nbsp;&nbsp;&nbsp;&nbsp;
        <van-button @click="toggleLike(0)" round size="small" :class="{active:article.attitude===0}" plain icon="delete">不喜欢</van-button>
      </div>
```

实现逻辑：点赞或不喜欢=》2选1

> 用户对文章的态度, -1: 无态度，0-不喜欢，1-点赞

```js
    // 点赞/不喜欢
    async toggleLike (type) {
      try {
        if (type === 1) {
          // 点赞=》取反
          if (this.detail.attitude === 1) {
            // 取消点赞
            await unLike(this.detail.art_id)
            this.detail.attitude = -1
          } else {
            // 点赞
            await like(this.detail.art_id)
            this.detail.attitude = 1
          }
        } else {
          // 不喜欢=》取反
          if (this.detail.attitude === 0) {
            // 取消不喜欢
            await unDisLike(this.detail.art_id)
            this.detail.attitude = -1
          } else {
            // 不喜欢
            await disLike(this.detail.art_id)
            this.detail.attitude = 0
          }
        }
        // 统一提示
        this.$toast.success('操作成功！')
      } catch (e) {
        this.$toast.fail('操作失败！')
      }
    }
```



### 05-文章详情-评论组件-评论列表布局

> 新建子组件，使用准备的评论结构和样式；在文章详情组件中渲染

* article目录下新建components目录和comment.vue评论组件

  * 评论列表布局

  * 底部评论输入框

`views/article/components/comment.vue`

开发模板：

```vue
<template>
<div class="comment">
<!-- 评论列表 -->
<van-list v-model="loading" :finished="finished" @load="loadComments" finished-text="没有更多了">
  <div class="item van-hairline--bottom van-hairline--top" v-for="index in 5"               :key="index">
    <van-image round width="1rem" height="1rem" fit="fill"                                   src="https://img.yzcdn.cn/vant/cat.jpeg" />
    <div class="info">
      <p>
        <span class="name">一阵清风</span>
        <span style="float:right">
          <span class="van-icon van-icon-good-job-o zan"></span>
          <span class="count">10</span>
        </span>
      </p>
      <p>评论的内容，。。。。</p>
      <p>
        <span class="time">两天内</span>&nbsp;
        <van-tag plain @click="showReply=true">4 回复</van-tag>
      </p>
    </div>
  </div>
</van-list>
<!-- 底部输入框 -->
<div class="reply-container van-hairline--top">
  <van-field v-model="value" placeholder="写评论...">
    <van-loading v-if="submiting" slot="button" type="spinner" size="16px">
    </van-loading>
    <span class="submit" v-else slot="button">提交</span>
  </van-field>
</div>
</div>  
</template>  
<script>
 export default { 
    data () {
    return {
      // 评论列表
      comments:[],
      // 评论列表加载中状态
      loading: false,
      // 评论列表完全加载完毕状态
      finished: false,
      // 输入的内容
      value: '',
      // 提交 评论或者回复 中
      submiting: false
    }
  },
 methods:{
   loadComments() {
      // 异步更新数据
      // setTimeout 仅做示例，真实场景中一般为 ajax 请求
      setTimeout(() => {
        for (let i = 0; i < 10; i++) {
          this.comments.push(this.comments.length + 1);
        }

        // 加载状态结束
        this.loading = false;

        // 数据全部加载完成
        if (this.comments.length >= 40) {
          this.finished = true;
        }
      }, 1000);
   }
 }   
 }
</script>  
<style lang="less" scoped>
.comment {
  margin-top: 10px;
  /deep/ .item {
    display: flex;
    padding: 10px 0;
    width: 100%;
    overflow: hidden;
    text-align: left;
    .info {
      flex: 1;
      padding-left: 10px;
      .name{
        color:#069;
      }
      .zan{
        vertical-align:middle;
        padding-right:2px;
      }
      .count{
        vertical-align:middle;
        font-size:10px;
        color: #666;
      }
      .time{
        color: #666;
      }
      p {
        padding: 5px 0;
        margin: 0;
      }
    }
  }
  /deep/ .van-button:active::before {
    background: transparent;
  }
}
.reply-container {
  position: fixed;
  left: 0;
  bottom: 0;
  height: 44px;
  width: 100%;
  background: #f5f5f5;
  z-index: 9999;
  .submit {
    font-size: 12px;
    color: #3296fa;
  }
}
</style>
```



* 引入到文章详情中渲染弹出层一般都是在组件根节点结束之前

`views/article/index.vue`

```js
import Comment from '@/views/article/components/comment'
```

```html
<van-nav-bar fixed title="文章详情" left-arrow @click-left="$router.back()" />
<div class="detail">
  ...
  <!-- 放置div.detail中 -->
  <!-- 评论 -->
  <Comment />
</div>  
```



### 06-文章详情-评论组件-评论列表渲染

> 获取评论列表数据并渲染

步骤：

1. 定义接口方法
2. 绑定list的加载事件，**阻止默认加载行为**=>主动上拉加载=》**避免缓存**
3. 组件**activated时**清空之前的数据，加载**新的评论数据**=>**保障时效性**

* 定义API `src/api/article.js`=>获取评论或评论回复

```js
/**
 * 获取评论或回复
 * @param {String} type - a 查询文章的评论  c 查询评论的回复
 * @param {String} source - 如果查询评论是文章的ID  如果查询回复是评论的ID
 * @param {String} offset - 查询每一页数据的最后一个数据的ID，当作下一页的偏移量
 * @param {String} limit - 每页显示多少条
 */
export function getComments ({ type, source, offset, limit = 10 }) {
  return request.get('comments', {
    params: {
      type, source, offset, limit
    }
  })
}

```

* 绑定加载事件=>**阻止默认加载两次**(是否在初始化时立即执行滚动位置检查)=>`immediate-check`

作用：:immediate-check="false"=》不执行滚动位置检查=》第一次列表数据不会被加载=》**手动控制**

说明：通过activated钩子手动加载=>避免缓存

```html
<van-list :immediate-check="false" v-model="loading" :finished="finished" @load="loadComments()"
```
组件激活时候加载：
```js
  activated () {
    // 清空上一篇文章的评论
    this.comments = []
    // 开启加载中效果
    this.loading = true
    // 重置 是否完全加载完毕 状态
    this.finished = false
    // 重置 偏移量
    this.offset = null
    this.loadComments()
  },
```
```js
    // 加载评论列表
    async loadComments () {
      const {data} = await getComments({
        type: 'a',
        source: this.$route.params.id,
        // 下一页开始请求的数据开始位置=》表示从此id的数据向后取
        offset: this.offset
      })
      this.comments.push(...data.results)
      // 结束加载状态
      this.loading = false
      // 判断是否有数据
      if (data.last_id > data.end_id) {
        this.offset = data.last_id
      } else {
        this.finished = true
      }
    }
```

渲染结构：

```html
      <div class="item van-hairline--bottom van-hairline--top" v-for="item in comments" :key="item.com_id.toString()">
        <van-image round width="1rem" height="1rem" fit="fill" :src="item.aut_photo" />
        <div class="info">
          <p>
            <span class="name">{{item.aut_name}}</span>
            <span style="float:right">
              <span class="van-icon van-icon-good-job-o zan"></span>
              <span class="count">{{item.like_count}}</span>
            </span>
          </p>
          <p>{{item.content}}</p>
          <p>
            <span class="time">{{item.pubdate|relTime}}</span>&nbsp;
            <van-tag plain @click="openReplyDialog(item.com_id.toString())">{{item.reply_count}} 回复</van-tag>
          </p>
        </div>
      </div>
```



### 07-文章详情-评论组件-回复评论列表布局

> 使用准备好的回复静态模版，了解基础结构布局

步骤：

1. 回复列表基础布局=》放到评论组件中根元素结束之前
2. 点击回复=〉打开回复窗口

结构：

`views/article/components/comment.vue`

```html
<!-- 回复 -->
<van-action-sheet v-model="showReply" class="reply_dailog" title="回复评论">
  <van-list v-model="reply.loading" :finished="reply.finished" finished-text="没有更多了">
    <div class="item van-hairline--bottom van-hairline--top" v-for="index in 8" :key="index">
      <van-image round width="1rem" height="1rem" fit="fill" src="https://img.yzcdn.cn/vant/cat.jpeg" />
      <div class="info">
        <p><span class="name">一阵清风</span></p>
        <p>评论的内容，。。。。</p>
        <p><span class="time">两天内</span></p>
      </div>
    </div>
  </van-list>
</van-action-sheet>
```

数据：

```js
// 显示回复对话框
showReply: false,
// 回复相关数据
reply: {
  loading: false,
  finished: false
}
```

样式：

```less
.van-popup--bottom{
  &.van-popup--round{
    border-radius: 0;
  }
}
.reply_dailog {
  height: 100%;
  max-height: 100%;
  display: flex;
  overflow: hidden;
  flex-direction: column;
  .van-action-sheet__header {
    background: #3296fa;
    color: #fff;
    .van-icon-close {
      color: #fff;
    }
  }
  .van-action-sheet__content{
    flex: 1;
    overflow-y: auto;
    padding: 0 10px 44px;
  }
}
```

* 绑定展示回复列表事件

```html
<van-tag plain @click="openReplyDialog()">{{item.reply_count}} 回复</van-tag>
```

```js
// 打开回复
openReplyDialog () {
  this.showReply = true
}
```



### 08-文章详情-评论组件-回复评论列表渲染(作业)

> 获取某个评论的回复列表数据并渲染

步骤：

- 使用获取评论的API，**参数改成 c** 即可。
- 点击的时候，获取当前点击的评论ID

`views/article/components/comment.vue`

设置回复列表数据：

```diff
// 回复相关数据
reply: {
  loading: false,
  finished: false,
+  // 回复列表
+  list: []
}
```

绑定点击事件获取评论ID：

```html
 <van-tag plain @click="openReplyDialog(item.com_id.toString())">{{item.reply_count}} 回复</van-tag>
```

关闭van-list主动上拉加载

```html
<van-list @load="loadReplys()" :immediate-check="false"  
```

当打开对话框的时候，获取ID，进行加载

```js
    // 打开回复对话框
    openReplyDialog (comId) {
      // 显示回复窗口
      this.showReply = true
      // 当前评论ID存储到this上
      this.commentId = comId
      // 清空 回复 列表
      this.reply.list = []
      // 开启加载效果
      this.reply.loading = true
      // 重置 没有更多数据
      this.reply.finished = false
      // 重置 偏移量
      this.reply.offset = null
      // 加载回复
      this.loadReplys()
    },
```

```js
    // 加载回复列表
    async loadReplys () {
      const {data} = await getComments({
        type: 'c',
        source: this.commentId,
        offset: this.reply.offset
      })
      this.reply.list.push(...data.results)
      // 结束加载状态
      this.reply.loading = false
      // 判断是否还有数
      if (data.last_id > data.end_id) {
        this.reply.offset = data.last_id
      } else {
        this.reply.finished = true
      }
    },
```

渲染组件：

```html
        <div class="item van-hairline--bottom van-hairline--top" v-for="item in reply.list" :key="item.com_id.toString()">
          <van-image round width="1rem" height="1rem" fit="fill" :src="item.aut_photo"/>
          <div class="info">
            <p><span class="name">{{item.aut_name}}</span></p>
            <p>{{item.content}}</p>
            <p><span class="time">{{item.pubdate|relTime}}</span></p>
          </div>
        </div>
```



### 09-文章详情-评论组件-评论与回复功能

> 实现对文章发表评论和回复文章下某条评论功能

说明：回复功能学生自己独立完成（作业）

- 封装API  `src/api/article.js`=》添加评论或评论回复

```js

/**
 * 提交评论或者回复
 * @param {String} target - 做评论的时候：文章ID  做回复的时候：评论ID
 * @param {String} content - 评论内容
 * @param {String} artId - 文章id，对评论内容发表回复时，需要传递此参数，表明所属文章id。对文章进行评论，不要传此参数
 */
export const commentOrReply = (target, content, art_id = null) => {
 return request.post('comments', { target, content, art_id })
}

```

- 绑定事件=》共用一个提交按钮

  * 根据showReply显示对应提示文字

```html
<van-field v-model.trim="value" :placeholder="showReply?'写回复...':'写评论...'">
```

```html
<span class="submit" @click="submit()" v-else slot="button">提交</span>
```

```js
    // 提交 评论或者回复
    async submit () {
      // 判断是否有输入内容
      if (!this.value) return false
      // 开启提交效果
      this.submiting = true
      try {
        if (this.showReply) {
        // 回复文章某条评论
          const {data} = await commentOrReply(this.commentId, this.value, this.$route.params.id)
          this.$toast.success('回复成功')
          // 在回复列表顶部追加一项数据 data.new_obj
          this.reply.list.unshift(data.new_obj)
          // 在当前回复的评论数据中 累加回复的数量
          const comment = this.comments.find(item => item.com_id.toString() === this.commentId)
          comment.reply_count++
        } else {
         // 对文章评论
          const {data} = await commentOrReply(this.$route.params.id, this.value)
          this.$toast.success('评论成功')
          this.comments.unshift(data.new_obj)
        }
        // 处理完毕
        // 关闭提交效果
        this.submiting = false
        // 清空内容
        this.value = ''
      } catch (e) {
        this.$toast.success('操作失败')
        this.submiting = false
      }
    }
```

### 第六天重点总结

