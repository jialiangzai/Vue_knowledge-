## 项目架构

### 01-路由规则

> 根据参考图，设计路由规则。

实现思路：使用路由的children（嵌套路由）实现

| path           | 功能         | 路由级别     |
| -------------- | ------------ | ------------ |
| /              | 布局组件     | **一级路由** |
| ├─ /           | 首页组件     | 二级路由     |
| ├─ /question   | 问答组件     | 二级路由     |
| ├─ /video      | 视频组件     | 二级路由     |
| ├─ /user       | 个人中心组件 | 二级路由     |
| /user/profile  | 编辑资料组件 | **一级路由** |
| /user/chat     | 小智同学组件 | **一级路由** |
| /login         | 登录组件     | **一级路由** |
| /search        | 搜索中心组件 | **一级路由** |
| /search/result | 搜索结果组件 | **一级路由** |
| /article       | 文章详情     | **一级路由** |



### 02-路由配置

> 根据设计的路由规则，定义路由和空组件

步骤：

1. 定义路由规则和空页面
2. 抽离为单独routes.js文件
3. 测试配置的路由页面

注意：在布局骨架页面，放置二级路由渲染的`router-view`标签

目录：`router/routes.js`

```js
/**
 * 路由配置
 */
/**
 * 前端路由配置的两种方式
 * 1. hash模式(默认)
 * 2. history模式
 * 相同点：都可以实现路由配置和跳转（功能一样）
 * 不同点：路由的路径不一样=》hash模式带个#号；history不带
 * 使用场景：
 * 一般使用hash模式，因为hash可以运行在所有浏览器（兼容性好）；
 * 但是history模式只能在支持history api的浏览器运行
 */

// 布局组件(一)
const Layout = () => import('@/views/layout.vue')
// 首页（第一个标签页）
const Index = () => import('@/views/home/index.vue')
// 问答
const Question = () => import('@/views/question/index.vue')
// 视频
const Video = () => import('@/views/video/index.vue')
// 个人中心
const Profile = () => import('@/views/profile/index.vue')
// 登录
const Login = () => import('@/views/login/index.vue')
// 编辑个人资料
const User = () => import('@/views/user/edit.vue')
// 小智
const Chat = () => import('@/views/user/chat.vue')
// 搜索
const Search = () => import('@/views/search/index.vue')
const Result = () => import('@/views/search/result.vue')
// 详情
const Article = () => import('@/views/article/index.vue')

const routes = [ 
  {
    path: '/',
    // 布局骨架
    component: Layout,
    // 二级路由
    children: [
      {
        path: '/',
        name: 'index',
        // 首页
        component: Index
      },
      {
        path: '/question',
        name: 'question',
        // 问答
        component: Question
      },
      {
        path: '/video',
        name: 'video',
        // 视频
        component: Video
      },
      {
        path: '/user',
        name: 'user',
        // 个人中心
        component: Profile
      }
    ]
  },
  {
    path: '/login',
    name: 'login',
    // 登录
    component: Login
  },
  {
    path: '/user/profile',
    name: 'profile',
    // 编辑资料
    component: User
  },
  {
    path: '/user/chat',
    name: 'chat',
    // 小智同学
    component: Chat
  },
  {
    path: '/search',
    name: 'search',
    // 搜索
    component: Search
  },
  {
    path: '/search/result',
    name: 'result',
    // 搜索结果
    component: Result
  },
  {
    path: '/article/:id',
    name: 'article',
    // 文章详情
    component: Article
  }
]

export default routes

```



### 03-layout骨架组件布局

> 处理布局组件结构样式和导航

步骤：

1. 根据文档，使用NavBar和Tabbar组件配置页面效果和路由导航
3. 如果选中的是 `我的` 标签，应该隐藏 NavBar , 内容容器 my-wrapper 去除上内边距。
4. 点击搜索，跳转到搜索中心页面。

`views/layout.vue`

```vue
<template>
  <div class="container">
    <!-- 头部 -->
    <!-- 当路由地址（path === $route.path）不是`我的`才显示 -->
    <van-nav-bar v-if="isShowNav" fixed title="黑马头条" right-text="搜索"
      @click-right="$router.push('/search')"/>
    <!-- 中间内容：二级路由挂载点=》注意容器样式添加 -->
    <div class="my-wrapper" :class="{noTop:!isShowNav}">
      <router-view></router-view>
    </div>
    <!-- 底部菜单 -->
    <van-tabbar route>
      <van-tabbar-item to="/" icon="home-o">首页</van-tabbar-item>
      <van-tabbar-item to="/question"  icon="chat-o">问答</van-tabbar-item>
      <van-tabbar-item to="/video"  icon="video-o">视频</van-tabbar-item>
      <van-tabbar-item to="/user"  icon="user-o">我的</van-tabbar-item>
    </van-tabbar>
  </div>
</template>

<script>
export default {
  computed: {
    isShowNav () {
      return this.$route.path !== '/user'
    }
  }
}
</script>

<style scoped lang='less'>
.container{
  width: 100%;
  height: 100%;
  position: relative;
  .my-wrapper{
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding-top: 46px;
    padding-bottom: 50px;
    box-sizing: border-box;
    &.noTop{
      padding-top: 0;
    }
  }
}
</style>
```



### 04-本地存储token

> 本地持久化token；将来实现刷新token，需要存储的信息。关闭浏览器后再次打开，需要保持登录状态。

回顾：pc端登录业务实现思路

1. 获取到手机号和验证码
2. 使用手机号和验证码作为接口参数发送登录请求
3. 登录请求成功=》后台返回什么？=》**token(登录成功的标识)=》存到localStorage中**
4. 跳转到后台的首页

步骤：

1. utils下新建auth.js
2. 使用localStorage处理token数据

目录：`src/utils/auth.js `

```js
/**
 * auth认证（令牌）
 * 之前用户信息存储位置是：sessionStorage，关闭浏览器登录失效
 * 保持登录状态：refresh_token结合localStorage来延长token有效期
 * token: {token, refresh_token}
 */

const TT_TOKEN = 'TT_TOKEN'

// 存储token
export function setToken (token) {
  window.localStorage.setItem(TT_TOKEN, JSON.stringify(token))
}

// 获取token
export function getToken () {
  return JSON.parse(window.localStorage.getItem(TT_TOKEN))
}

// 删除token
export function delToken () {
  window.localStorage.removeItem(TT_TOKEN)
}

```



### 05-vuex管理token

> 使用vuex管理和共享token

- 共享token数据
- 在vuex中更好操作，更好监听。

存在问题：

> 刷新页面的场景=> 结合本地存储做数据持久化

步骤：

1. state中增加user字段，默认值从本地获取
2. mutations中添加修改方法setToken()和delToken

`src/store/index.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'

// 导入token方法
import * as auth from '@/utils/auth'
// console.log(auth)

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    // 用户token
    user: auth.getToken() || {}
  },
  mutations: {
    // 设置token
    setToken (state, token) {
      // 设置state
      state.user = token
      // 更新本地(刷新页面后，可以获取到上一次存储到token数据)
      auth.setToken(token)
    },
    // 删除token(清除本地用户登录信息)
    delToken (state) {
      state.user = {}
      auth.delToken()
    }

  },
  actions: {
  }
})

```



### 06-路由守卫

> 使用前置路由守卫，拦截'/user'开头的路由页面，没有登录不能访问

步骤：

1. 获取vuex中的token数据
2. 判断是否需要登录访问

`src/router.js`

```js
import store from '@/store'
```

```js
// 路由守卫=>前置守卫
router.beforeEach((to, from, next) => {
  // 获取token信息
  const { user } = store.state
  console.log(user)
  const loginConfig = { path: '/login', query: { redirectUrl: to.path } }
  if (to.path.startsWith('/user') && !user?.token) {
    next(loginConfig)
  } else {
    next()
  }
})
```

- 地址 `/user` 开头的路径，**检查是否登录**。
- 如果没有 重定向到  登录页面。

扩展阅读：https://router.vuejs.org/zh/guide/advanced/navigation-guards.html

注意⚠️：

遇到：`vue-router.esm.js?8c4f:1995 Uncaught (in promise) Error: Redirected when going from "/video" to "/user" via a navigation guard.`

```js
// 解决Vue-Router升级导致的Uncaught(in promise) navigation guard问题
const originalPush = VueRouter.prototype.push
VueRouter.prototype.push = function push (location, onResolve, onReject) {
  if (onResolve || onReject) return originalPush.call(this, location, onResolve, onReject)
  return originalPush.call(this, location).catch(err => err)
}
```



### 第二天重点总结

### 07-初步封装request工具

> 封装的目的：复用，导出一个调用请求的全局axios函数。

安装：

```sh
$ npm i axios json-bigint
```

步骤：

1. 创建自定义配置的axios函数
* 设置基础请求地址：http://geek.itheima.net/v1_0/
* 在transformResponse中处理响应res数据的大整型数据精度丢失问题

2. 导入创建的store对象，获取token数据
3. 在请求拦截器中，统一处理请求头中携带token，排除登录注册等接口（根据接口文档）
4. 在响应拦截器中，处理和简化返回的数据

   最后，测试自定义axios方法

`utils/request.js`

```js
/**
 * 封装全局接口请求axios函数
 */

import axios from 'axios'
import JSONBIGINT from 'json-bigint'
// 导入store
import store from '../store'

const MyAxios = axios.create({
  baseURL: 'http://toutiao-app.itheima.net/v1_0/',
  transformResponse: [function (data) {
    console.log('1', data)
    // Do whatever you want to transform the data
    // data =>后台返回的JSON字符串
    try {
      // 处理JSON.parse/stringify精度丢失
      // test:console.log(JSONBIGINT.parse('{"a":9223372036854775807}').a.toString(), JSON.parse('{"a":9223372036854775807}'))

      return JSONBIGINT.parse(data)
    } catch (e) {
      return data
    }
  }
  ]

})

// Add a request interceptor
MyAxios.interceptors.request.use(function (config) {
  // Do something before request is sent
  // 请求之前，统一向header中加入token
  // ?.user 处理null
  // 排除登录注册等接口
  if (store.state.user.token && config.url !== 'authorizations') {
    config.headers.Authorization = `Bearer ${store.state.user.token}`
  }
  return config
}, function (error) {
  // Do something with request error
  return Promise.reject(error)
})

// Add a response interceptor
MyAxios.interceptors.response.use(function (response) {
  // Any status code that lie within the range of 2xx cause this function to trigger
  // Do something with response data
  // 处理和简化返回的数据
  return {
    status: response.status,
    data: response.data.data
  }
}, function (error) {
  // Any status codes that falls outside the range of 2xx cause this function to trigger
  // Do something with response error
  return Promise.reject(error)
})

// 导出axios
export default MyAxios

```

测试使用代码：

```js
<script>
import request from '@/utils/request.js'  
export default {
  name: 'home-index',
  created () {
    // 获取系统公告列表=> 测试使用
    request.get('announcements', {
      params: {
        id: 10
      }
    }).then((res) => {
      console.log(res)
    })
  }
}
</script>
```

注意⚠️：以上没有处理token失效，后续登录实现后完成



